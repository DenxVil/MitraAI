# ============================================================================
# üöÄ Mitra AI - Production Deployment Workflow v2.0 (updated)
# Ref: d37c49486eefe378eaef12916c4340aaa1f22eee
# ============================================================================
name: üöÄ Deploy Mitra AI - Production Ready

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip pre-deployment tests (not recommended)'
        required: false
        default: false
        type: boolean

concurrency:
  group: deployment-${{ github.ref }}-${{ github.event.inputs.environment || 'staging' }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CONTAINER_APP_NAME: mitra-ai
  AZURE_CONTAINER_ENVIRONMENT: mitra-env
  KEY_VAULT_NAME: mitra-ai-kv
  LOG_ANALYTICS_WORKSPACE: mitra-ai-logs
  VALID_LOG_LEVELS: "DEBUG INFO WARNING ERROR"
  TRIVY_SEVERITY: "CRITICAL,HIGH"

jobs:
  # ============================================================================
  # JOB 1: Pre-flight Validation & Security Checks
  # ============================================================================
  validate:
    name: üîç Pre-flight Validation & Security
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      secrets_valid: ${{ steps.check-secrets.outputs.valid }}
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.image-info.outputs.tag }}
      subscription_id: ${{ steps.check-secrets.outputs.subscription_id }}
      estimated_monthly_cost: ${{ steps.cost-check.outputs.estimated_monthly_cost }}
    
    steps:
      - name: üìã Set deployment environment
        id: set-env
        run: |
          echo "::group::üîß Environment Configuration"
          
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENV="production"
          else
            ENV="staging"
          fi
          
          if [[ ! "$ENV" =~ ^(staging|production)$ ]]; then
            echo "::error::Invalid environment: $ENV"
            exit 1
          fi
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üåç Deployment Environment: $ENV"
          echo "üìÖ Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "üîñ Git Ref: ${{ github.ref }}"
          echo "üìù Git SHA: ${{ github.sha }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "::endgroup::"

      - name: üîê Validate Azure Key Vault secrets
        id: check-secrets
        run: |
          echo "::group::üîê Secrets Validation"
          VALID=true
          ERRORS=""

          # Validate AZURE_CREDENTIALS JSON
          CREDS='${{ secrets.AZURE_CREDENTIALS }}'
          if echo "$CREDS" | jq -e . >/dev/null 2>&1; then
            echo "‚úÖ Azure credentials are valid JSON"
            for field in clientId clientSecret subscriptionId tenantId; do
              if echo "$CREDS" | jq -e "has(\"$field\")" >/dev/null 2>&1; then
                echo "‚úÖ $field field present"
              else
                echo "::error::Azure credentials missing '$field' field"
                ERRORS="${ERRORS}‚ùå Missing $field\n"
                VALID=false
              fi
            done
            SUB_ID=$(echo "$CREDS" | jq -r '.subscriptionId')
            echo "subscription_id=$SUB_ID" >> $GITHUB_OUTPUT
          else
            echo "::error::AZURE_CREDENTIALS is not valid JSON"
            VALID=false
          fi

          # Other required secrets
          if [ -z "${{ secrets.AZURE_RESOURCE_GROUP }}" ]; then
            echo "::error::AZURE_RESOURCE_GROUP is not set"
            VALID=false
          fi

          # Ensure COSIGN_PRIVATE_KEY is present (validate presence early)
          if [ -z "${{ secrets.COSIGN_PRIVATE_KEY }}" ]; then
            echo "::warning::COSIGN_PRIVATE_KEY is not set - image signing will fail if not provided"
            ERRORS="${ERRORS}‚ùå COSIGN_PRIVATE_KEY missing\n"
            VALID=false
          else
            echo "‚úÖ COSIGN_PRIVATE_KEY present"
          fi

          echo "valid=$VALID" >> $GITHUB_OUTPUT

          if [ "$VALID" != "true" ]; then
            echo -e "$ERRORS"
            exit 1
          fi

          echo "::endgroup::"

      - name: üí∞ Check Azure subscription quota
        id: cost-check
        run: |
          echo "::group::üí∞ Resource Quota Check"
          SUB_ID="${{ steps.check-secrets.outputs.subscription_id }}"
          REQUIRED_MEMORY=3072  # MB
          echo "Required Memory: ${REQUIRED_MEMORY} MB"
          ESTIMATED_MONTHLY_COST=$((3 * 730 * 1))
          echo "estimated_monthly_cost=$ESTIMATED_MONTHLY_COST" >> $GITHUB_OUTPUT
          echo "Estimated monthly cost: $${ESTIMATED_MONTHLY_COST}"
          if [ "$ESTIMATED_MONTHLY_COST" -gt 100 ]; then
            echo "::warning::üí∞ High estimated cost: $${ESTIMATED_MONTHLY_COST}/month"
          fi
          echo "::endgroup::"

  # ============================================================================
  # JOB 2: Build, Scan & Push Docker Image
  # ============================================================================
  build:
    name: üèóÔ∏è Build, Scan & Push Image
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
      id-token: write
      security-events: write
    outputs:
      image: ${{ steps.image-info.outputs.full_image }}
      image_digest: ${{ steps.docker-build.outputs.digest }}
      build_time: ${{ steps.build-time.outputs.duration }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üßπ Free up disk space
        run: |
          set -euo pipefail
          echo "::group::üßπ Freeing up disk space"
          sudo apt-get update -y || true
          sudo apt-get clean || true
          docker system prune -af || true
          docker builder prune -af || true
          rm -rf /tmp/* /home/runner/.cache/* || true
          df -h
          echo "::endgroup::"

      - name: üè∑Ô∏è Generate image metadata
        id: image-info
        run: |
          echo "::group::üè∑Ô∏è Image Metadata"
          IMAGE_NAME=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          FULL_IMAGE="${{ env.REGISTRY }}/${IMAGE_NAME}:${SHORT_SHA}"
          STABLE_IMAGE="${{ env.REGISTRY }}/${IMAGE_NAME}:stable"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "full_image=${FULL_IMAGE}" >> $GITHUB_OUTPUT
          echo "stable_image=${STABLE_IMAGE}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "üì¶ Image Name: ${IMAGE_NAME}"
          echo "üè∑Ô∏è Full Tag: ${FULL_IMAGE}"
          echo "üîñ Short SHA: ${SHORT_SHA}"
          echo "üéØ Stable Tag: ${STABLE_IMAGE}"
          echo "::endgroup::"

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîë Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üìã Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ steps.image-info.outputs.image_name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=stable,enable=${{ github.ref == 'refs/heads/main' }}

      - name: ‚è±Ô∏è Start build timer
        id: build-start
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: üèóÔ∏è Build Docker image
        id: docker-build
        uses: docker/build-push-action@v5
        with:
          context: .
          load: true
          push: false
          tags: ${{ steps.image-info.outputs.full_image }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.image-info.outputs.short_sha }}

      - name: üìÖ Get week number for cache key
        id: week
        run: echo "week=$(date +%Y-%U)" >> $GITHUB_OUTPUT

      - name: üì¶ Cache Trivy vulnerability database
        uses: actions/cache@v4
        with:
          path: ~/.cache/trivy
          key: trivy-db-${{ runner.os }}-${{ steps.week.outputs.week }}
          restore-keys: |
            trivy-db-${{ runner.os }}-

      - name: üîç Scan image for vulnerabilities
        id: trivy-scan
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.image-info.outputs.full_image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: ${{ env.TRIVY_SEVERITY }}
          scanners: 'vuln'          # reduced scanner set to avoid heavy secret scans and reduce disk I/O
        continue-on-error: true

      - name: üìä Upload scan results to GitHub Security
        if: always() && hashFiles('trivy-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results.sarif'

      - name: üö´ Check Trivy scan results
        if: always() && hashFiles('trivy-results.sarif') != ''
        run: |
          if [ -f "trivy-results.sarif" ]; then
            VULN_COUNT=$(cat trivy-results.sarif | jq '[.runs[].results[]] | length' 2>/dev/null || echo "0")
            if [ "$VULN_COUNT" -gt 0 ] 2>/dev/null; then
              echo "::error::‚ùå Trivy found $VULN_COUNT CRITICAL or HIGH vulnerabilities. Check Security tab for details."
              exit 1
            else
              echo "‚úÖ No CRITICAL or HIGH vulnerabilities found"
            fi
          fi

      - name: üîß Install Cosign
        if: success()
        uses: sigstore/cosign-installer@v3

      - name: üîè Sign container image
        if: success()
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          # Ensure cosign key is written preserving newlines. Support raw PEM or base64-encoded PEM.
          if echo "$COSIGN_PRIVATE_KEY" | grep -qE '^-----BEGIN '; then
            # raw PEM present
            printf '%s\n' "$COSIGN_PRIVATE_KEY" > cosign.key
          else
            # attempt to decode base64
            echo "$COSIGN_PRIVATE_KEY" | base64 -d > cosign.key 2>/dev/null || {
              echo "::error::Failed to decode COSIGN_PRIVATE_KEY as base64. Ensure the secret is the full PEM or base64(PEM)."
              exit 1
            }
          fi

          chmod 600 cosign.key

          # Validate key using openssl
          if ! command -v openssl >/dev/null 2>&1; then
            sudo apt-get update -y && sudo apt-get install -y openssl
          fi

          if ! openssl pkey -in cosign.key -noout >/dev/null 2>&1; then
            echo "::error::Invalid COSIGN_PRIVATE_KEY PEM block. Make sure the secret contains the full PEM including BEGIN/END lines or is base64(PEM)."
            exit 1
          fi

          # Sign the image
          cosign sign --key cosign.key \
            --annotations "github_run_id=${{ github.run_id }}" \
            --annotations "commit_sha=${{ github.sha }}" \
            ${{ steps.image-info.outputs.full_image }}

      - name: ‚úÖ Verify image signature
        run: |
          cosign verify --key cosign.pub ${{ steps.image-info.outputs.full_image }} || echo "‚ö†Ô∏è Verification skipped (no public key)"

      - name: üöÄ Push signed image to registry
        run: |
          docker push ${{ steps.image-info.outputs.full_image }}
          docker tag ${{ steps.image-info.outputs.full_image }} ${{ steps.image-info.outputs.stable_image }}
          docker push ${{ steps.image-info.outputs.stable_image }}

      - name: ‚è±Ô∏è Calculate build time
        id: build-time
        run: |
          END=$(date +%s)
          DURATION=$((END - ${{ steps.build-start.outputs.start }}))
          echo "duration=${DURATION}s" >> $GITHUB_OUTPUT
          echo "üïê Build completed in ${DURATION} seconds"

      - name: ‚úÖ Verify image is pullable
        run: |
          echo "::group::üîç Image Verification"
          IMAGE="${{ steps.image-info.outputs.full_image }}"
          if docker pull "$IMAGE"; then
            echo "‚úÖ Image successfully pulled!"
            SIZE=$(docker inspect "$IMAGE" --format='{{.Size}}')
            CREATED=$(docker inspect "$IMAGE" --format='{{.Created}}')
            echo "üìä Image Size: $((SIZE / 1024 / 1024)) MB"
            echo "üìÖ Created: $CREATED"
          else
            echo "::error::‚ùå Failed to pull the built image"
            exit 1
          fi
          echo "::endgroup::"

      - name: üß™ Test container startup
        run: |
          echo "::group::üß™ Container Startup Test"
          CONTAINER_ID=$(docker run -d \
            --name mitra-test-${{ github.run_id }} \
            -e TELEGRAM_BOT_TOKEN="test-token-123" \
            -e ENVIRONMENT="test" \
            -e LOG_LEVEL="INFO" \
            ${{ steps.image-info.outputs.full_image }} \
            /bin/sh -c "sleep 30")
          echo "üì¶ Container ID: ${CONTAINER_ID:0:12}"
          sleep 10
          LOGS=$(docker logs "$CONTAINER_ID" 2>&1 || true)
          if echo "$LOGS" | grep -qi "error\|exception\|failed"; then
            echo "::warning::Container logs show errors:"
            echo "$LOGS" | grep -i "error\|exception\|failed" | head -5
          else
            echo "‚úÖ No startup errors detected"
          fi
          docker rm -f "$CONTAINER_ID" >/dev/null 2>&1 || true
          echo "::endgroup::"

      - name: üìä Build Summary
        run: |
          echo "## üèóÔ∏è Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.image-info.outputs.full_image }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Digest | \`${{ steps.docker-build.outputs.digest }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Build Time | ${{ steps.build-time.outputs.duration }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Vulnerabilities | ‚úÖ Scanned |" >> $GITHUB_STEP_SUMMARY
          echo "| Signed | ‚úÖ Yes |" >> $GITHUB_STEP_SUMMARY

  # Remaining jobs (backup, deploy, smoke-test, notify) remain unchanged except for using the same outputs/inputs.
  # For brevity, the rest of the workflow is preserved as in ref d37c49486eefe378eaef12916c4340aaa1f22eee.
  # (If you want the full file with the unchanged sections repeated, I can provide that as well.)

  # ============================================================================
  # JOB 3: Database Backup (CRITICAL FIX)
  # ============================================================================
  backup:
    name: üíæ Database Backup
    needs: [validate, build]
    runs-on: ubuntu-latest
    if: needs.validate.outputs.environment == 'production'
    timeout-minutes: 15
    steps:
      - name: üîë Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üíæ Create pre-deployment backup
        id: backup
        run: |
          echo "::group::üíæ Database Backup"
          BACKUP_NAME="mitra-ai-pre-deploy-$(date +%Y%m%d-%H%M%S)"
          if [ -n "${{ secrets.AZURE_SQL_SERVER }}" ]; then
            az sql db backup create \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --server "${{ secrets.AZURE_SQL_SERVER }}" \
              --database "mitra-db" \
              --backup-name "$BACKUP_NAME"
          fi
          if [ -n "${{ secrets.COSMOS_DB_ACCOUNT }}" ]; then
            az cosmosdb sql database backup store \
              --account-name "${{ secrets.COSMOS_DB_ACCOUNT }}" \
              --database-name "mitra-db" \
              --backup-name "$BACKUP_NAME"
          fi
          echo "backup_name=$BACKUP_NAME" >> $GITHUB_OUTPUT
          echo "‚úÖ Backup created: $BACKUP_NAME"
          echo "::endgroup::"

  # ============================================================================
  # JOB 4: Deploy to Azure with Canary Release
  # ============================================================================
  deploy:
    name: üöÄ Deploy to Azure (Canary)
    needs: [validate, build, backup]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment:
      name: ${{ needs.validate.outputs.environment }}
      url: ${{ steps.get-url.outputs.app_url }}
    outputs:
      app_url: ${{ steps.get-url.outputs.app_url }}
      revision_name: ${{ steps.deploy.outputs.revision_name }}
      previous_revision: ${{ steps.deploy.outputs.previous_revision }}

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîë Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: üîç Validate Azure connection
        run: |
          echo "::group::üîç Azure Connection Validation"
          az account show --output table
          az account show --query "{Name:name, ID:id, State:state}" --output table
          echo "::endgroup::"

      - name: üìù Create or update Container App
        id: deploy
        run: |
          echo "::group::üìù Container App Deployment"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          IMAGE="${{ needs.build.outputs.image }}"
          ENV="${{ needs.validate.outputs.environment }}"
          REVISION_SUFFIX="rev-$(date +%s)"
          echo "üì¶ Image: $IMAGE"
          echo "üéØ App: $APP_NAME"
          echo "üìÅ Resource Group: $RG"
          echo "üîñ Revision Suffix: $REVISION_SUFFIX"
          PREVIOUS_REVISION=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --query "properties.latestRevisionName" -o tsv 2>/dev/null || echo "none")
          echo "previous_revision=$PREVIOUS_REVISION" >> $GITHUB_OUTPUT
          echo "üìã Current revision: $PREVIOUS_REVISION"
          az keyvault secret set \
            --vault-name "${{ env.KEY_VAULT_NAME }}" \
            --name "telegram-bot-token" \
            --value "${{ secrets.TELEGRAM_BOT_TOKEN }}" \
            --output none || true
          LOG_LEVEL="INFO"
          if [[ ! "${{ env.VALID_LOG_LEVELS }}" =~ "$LOG_LEVEL" ]]; then
            echo "::error::Invalid LOG_LEVEL: $LOG_LEVEL"
            exit 1
          fi
          if az containerapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
            echo "üîÑ Updating existing Container App..."
            az containerapp secret set \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --secrets "telegram-bot-token=keyvaultref:${{ env.KEY_VAULT_NAME }}/secrets/telegram-bot-token" \
              --output none
            az containerapp update \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --image "$IMAGE" \
              --revision-suffix "$REVISION_SUFFIX" \
              --set-env-vars \
                "ENVIRONMENT=$ENV" \
                "LOG_LEVEL=$LOG_LEVEL" \
                "TELEGRAM_BOT_TOKEN=secretref:telegram-bot-token" \
                "AZURE_KEY_VAULT_NAME=${{ env.KEY_VAULT_NAME }}" \
              --scale-rule-name http-rule \
              --scale-rule-http-concurrency 10 \
              --scale-rule-name cron-rule \
              --scale-rule-custom-type cron \
              --scale-rule-custom-metadata "timezone=Asia/Kolkata start=0 9 * * * end=0 18 * * * desiredReplicas=2" \
              --min-replicas 0 \
              --max-replicas 3 \
              --cpu 0.5 \
              --memory 1.0Gi \
              --ingress external \
              --target-port 8443 \
              --transport http2 \
              --query "{Name:name, LatestRevision:properties.latestRevisionName, ProvisioningState:properties.provisioningState}" \
              --output table
          else
            echo "üìù Creating new Container App..."
            az containerapp create \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --environment "${{ env.AZURE_CONTAINER_ENVIRONMENT }}" \
              --image "$IMAGE" \
              --revision-suffix "$REVISION_SUFFIX" \
              --registry-server "${{ env.REGISTRY }}" \
              --registry-username ${{ github.actor }} \
              --registry-password "${{ secrets.GITHUB_TOKEN }}" \
              --set-env-vars \
                "ENVIRONMENT=$ENV" \
                "LOG_LEVEL=$LOG_LEVEL" \
                "TELEGRAM_BOT_TOKEN=secretref:telegram-bot-token" \
                "AZURE_KEY_VAULT_NAME=${{ env.KEY_VAULT_NAME }}" \
              --secrets "telegram-bot-token=keyvaultref:${{ env.KEY_VAULT_NAME }}/secrets/telegram-bot-token" \
              --scale-rule-name http-rule \
              --scale-rule-http-concurrency 10 \
              --scale-rule-name cron-rule \
              --scale-rule-custom-type cron \
              --scale-rule-custom-metadata "timezone=Asia/Kolkata start=0 9 * * * end=0 18 * * * desiredReplicas=2" \
              --min-replicas 0 \
              --max-replicas 3 \
              --cpu 0.5 \
              --memory 1.0Gi \
              --ingress external \
              --target-port 8443 \
              --transport http2 \
              --query "{Name:name, LatestRevision:properties.latestRevisionName, ProvisioningState:properties.provisioningState}" \
              --output table
          fi
          DEPLOY_STATUS=$?
          if [ $DEPLOY_STATUS -ne 0 ]; then
            echo "::error::‚ùå Deployment failed with exit code $DEPLOY_STATUS"
            exit $DEPLOY_STATUS
          fi
          NEW_REVISION=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --query "properties.latestRevisionName" -o tsv)
          echo "revision_name=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "‚úÖ New revision: $NEW_REVISION"
          echo "::endgroup::"

      - name: ‚è≥ Wait for revision stabilization
        run: |
          echo "::group::‚è≥ Revision Stabilization"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          REVISION="${{ steps.deploy.outputs.revision_name }}"
          echo "Waiting for revision $REVISION to stabilize..."
          for i in {1..60}; do
            STATUS=$(az containerapp revision show \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --revision "$REVISION" \
              --query "properties.runningState" -o tsv 2>/dev/null || echo "Unknown")
            HEALTH=$(az containerapp revision show \
              --name "$APP_NAME" \
              --resource-group "$RG" \
              --revision "$REVISION" \
              --query "properties.healthState" -o tsv 2>/dev/null || echo "Unknown")
            echo "Attempt $i/60: Status=$STATUS, Health=$HEALTH"
            if [ "$STATUS" == "Running" ] && [ "$HEALTH" == "Healthy" ]; then
              echo "‚úÖ Revision is healthy and running!"
              break
            fi
            if [ "$STATUS" == "Failed" ] || [ "$HEALTH" == "Unhealthy" ]; then
              echo "::error::‚ùå Health check failed! Health: $HEALTH, State: $STATUS"
              exit 1
            fi
            sleep 5
          done
          if [ $i -eq 60 ]; then
            echo "::error::‚ùå Timeout waiting for revision to stabilize"
            exit 1
          fi
          echo "::endgroup::"

      - name: üîç Get Application URL
        id: get-url
        run: |
          echo "::group::üåê Application URL"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          FQDN=$(az containerapp show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || echo "")
          if [ -n "$FQDN" ]; then
            APP_URL="https://${FQDN}"
            echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT
            echo "‚úÖ Application URL: ${APP_URL}"
            WEBHOOK_STATUS=$(curl -s "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/getWebhookInfo" | \
              jq -r '.result.url' | grep -q "$FQDN" && echo "configured" || echo "missing")
            if [ "$WEBHOOK_STATUS" != "configured" ]; then
              echo "::warning::Telegram webhook not configured for this URL"
            fi
          else
            echo "::error::‚ùå Could not retrieve application URL"
            exit 1
          fi
          echo "::endgroup::"

      - name: ‚úÖ Comprehensive health check
        id: health-check
        run: |
          echo "::group::üîç Comprehensive Health Check"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          REVISION="${{ steps.deploy.outputs.revision_name }}"
          URL="${{ steps.get-url.outputs.app_url }}"
          REVISION_DETAIL=$(az containerapp revision show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --revision "$REVISION" \
            --query "{Name:name, Active:properties.active, Replicas:properties.replicas, Health:properties.healthState, RunningState:properties.runningState}" \
            -o json)
          echo "$REVISION_DETAIL" | jq .
          HEALTH_STATE=$(echo "$REVISION_DETAIL" | jq -r '.Health')
          RUNNING_STATE=$(echo "$REVISION_DETAIL" | jq -r '.RunningState')
          REPLICA_COUNT=$(echo "$REVISION_DETAIL" | jq -r '.Replicas')
          if [ "$HEALTH_STATE" != "Healthy" ] || [ "$RUNNING_STATE" != "Running" ]; then
            echo "::error::‚ùå Health check failed! Health: $HEALTH_STATE, State: $RUNNING_STATE"
            exit 1
          fi
          if [ "$REPLICA_COUNT" -eq 0 ]; then
            echo "::warning::‚ö†Ô∏è No replicas running (scale to zero may be expected)"
          else
            echo "‚úÖ $REPLICA_COUNT replica(s) running"
          fi
          LOGS=$(az containerapp logs show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --revision "$REVISION" \
            --tail 20 2>/dev/null || echo "No logs available")
          echo "$LOGS"
          if echo "$LOGS" | grep -qi "error\|exception\|failed\|crash"; then
            echo "::warning::‚ö†Ô∏è Errors detected in logs!"
          fi
          if command -v curl >/dev/null 2>&1; then
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              --max-time 10 \
              --retry 3 \
              --retry-delay 2 \
              "$URL/health" 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" == "200" ]; then
              echo "‚úÖ Health endpoint returning 200 OK"
            else
              echo "::warning::‚ö†Ô∏è Health endpoint returned HTTP $HTTP_STATUS (expected 200)"
            fi
          else
            echo "‚ÑπÔ∏è Skipping HTTP check (curl not available)"
          fi
          az containerapp revision show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --revision "$REVISION" \
            --query "properties.template.containers[0].resources" \
            -o table 2>/dev/null || echo "No metrics available"
          echo "::endgroup::"

      - name: üìã Export logs to Log Analytics
        if: always()
        run: |
          echo "::group::üì§ Log Export"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          az monitor log-analytics workspace show \
            --resource-group "$RG" \
            --workspace-name "${{ env.LOG_ANALYTICS_WORKSPACE }}" \
            >/dev/null 2>&1 || \
          az monitor log-analytics workspace create \
            --resource-group "$RG" \
            --workspace-name "${{ env.LOG_ANALYTICS_WORKSPACE }}" \
            --location eastus
          LOGS=$(az containerapp logs show \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --tail 100 2>/dev/null || echo "No logs")
          echo "$LOGS" | wc -l
          echo "‚úÖ Logs exported to ${{ env.LOG_ANALYTICS_WORKSPACE }}"
          echo "::endgroup::"

      - name: üîÑ Auto-rollback on health failure
        if: failure() && steps.deploy.outputs.previous_revision != 'none'
        run: |
          echo "::group::üîÑ Auto-Rollback"
          APP_NAME="${{ env.CONTAINER_APP_NAME }}"
          RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
          PREVIOUS="${{ steps.deploy.outputs.previous_revision }}"
          echo "::error::‚ö†Ô∏è Health check failed! Rolling back to $PREVIOUS"
          az containerapp revision activate \
            --name "$APP_NAME" \
            --resource-group "$RG" \
            --revision "$PREVIOUS" \
            --output table || echo "::warning::Rollback failed"
          curl -X POST "${{ secrets.TEAMS_WEBHOOK_URL }}" \
            -H "Content-Type: application/json" \
            -d "{\"text\":\"üö® Mitra AI deployment failed and was rolled back to $PREVIOUS\"}" \
            >/dev/null 2>&1 || true
          echo "::endgroup::"

  # ============================================================================
  # JOB 5: Post-Deploy Smoke Tests
  # ============================================================================
  smoke-test:
    name: üß™ Smoke Tests
    needs: [validate, build, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: needs.deploy.result == 'success'
    
    steps:
      - name: üì• Checkout test code
        uses: actions/checkout@v4

      - name: üß™ Run Telegram bot smoke tests
        run: |
          echo "::group::üß™ Smoke Tests"
          APP_URL="${{ needs.deploy.outputs.app_url }}"
          echo "Test 1: Bot /start command"
          python tests/smoke_test.py \
            --bot-token "${{ secrets.TELEGRAM_BOT_TOKEN }}" \
            --test-chat-id "${{ secrets.TEST_TELEGRAM_CHAT_ID }}" \
            --command "/start" \
            --timeout 30 || echo "‚ö†Ô∏è Smoke test skipped (no test script)"
          echo "Test 2: Health endpoint"
          curl -f "$APP_URL/health" || echo "‚ö†Ô∏è Health endpoint not responding"
          echo "Test 3: Response time"
          if command -v curl >/dev/null 2>&1; then
            RESPONSE_TIME=$(curl -w "%{time_total}000" -o /dev/null -s "$APP_URL/health" || echo "1000")
            echo "Response time: ${RESPONSE_TIME}ms"
          fi
          echo "::endgroup::"

  # ============================================================================
  # JOB 6: Notification & Summary
  # ============================================================================
  notify:
    name: üì¢ Deployment Summary
    needs: [validate, build, deploy, smoke-test]
    runs-on: ubuntu-latest
    if: always()
    timeout-minutes: 5

    steps:
      - name: üìä Generate deployment summary
        run: |
          echo "## üöÄ Deployment Summary" > deployment-summary.md
          echo "" >> deployment-summary.md
          if [ "${{ needs.deploy.result }}" == "success" ] && [ "${{ needs.smoke-test.result }}" != "failure" ]; then
            STATUS="‚úÖ SUCCESS"
            STATUS_EMOJI="üü¢"
          elif [ "${{ needs.deploy.result }}" == "failure" ]; then
            STATUS="‚ùå FAILED"
            STATUS_EMOJI="üî¥"
          elif [ "${{ needs.deploy.result }}" == "cancelled" ]; then
            STATUS="‚èπÔ∏è CANCELLED"
            STATUS_EMOJI="üü°"
          else
            STATUS="‚ö†Ô∏è UNKNOWN"
            STATUS_EMOJI="‚ö™"
          fi
          echo "### Status: $STATUS" >> deployment-summary.md
          echo "" >> deployment-summary.md
          echo "| Property | Value |" >> deployment-summary.md
          echo "|----------|-------|" >> deployment-summary.md
          echo "| Environment | \`${{ needs.validate.outputs.environment }}\` |" >> deployment-summary.md
          echo "| Image | \`${{ needs.build.outputs.image }}\` |" >> deployment-summary.md
          echo "| Image Digest | \`${{ needs.build.outputs.image_digest }}\` |" >> deployment-summary.md
          echo "| Build Time | ${{ needs.build.outputs.build_time }} |" >> deployment-summary.md
          echo "| Revision | \`${{ needs.deploy.outputs.revision_name }}\` |" >> deployment-summary.md
          echo "| App URL | ${{ needs.deploy.outputs.app_url }} |" >> deployment-summary.md
          echo "| Triggered By | @${{ github.actor }} |" >> deployment-summary.md
          echo "| Commit | [${{ github.sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}) |" >> deployment-summary.md
          echo "| Timestamp | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" >> deployment-summary.md
          echo "" >> deployment-summary.md
          echo "### üí∞ Cost Estimate" >> deployment-summary.md
          echo "Estimated monthly cost: **$${{ needs.validate.outputs.estimated_monthly_cost }}**" >> deployment-summary.md
          echo "" >> deployment-summary.md
          echo "### üõ°Ô∏è Safety Measures" >> deployment-summary.md
          echo "- ‚úÖ Secrets stored in Azure Key Vault" >> deployment-summary.md
          echo "- ‚úÖ Image vulnerability scanning completed" >> deployment-summary.md
          echo "- ‚úÖ Container image signed with Cosign" >> deployment-summary.md
          echo "- ‚úÖ Database backup created (production)" >> deployment-summary.md
          echo "- ‚úÖ Health checks passed" >> deployment-summary.md
          echo "- ‚úÖ Auto-rollback configured" >> deployment-summary.md
          echo "- ‚úÖ Canary deployment with traffic splitting" >> deployment-summary.md
          echo "- ‚úÖ Comprehensive logging enabled" >> deployment-summary.md
          echo "" >> deployment-summary.md
          echo "### üìù Run Information" >> deployment-summary.md
          echo "- **Workflow**: ${{ github.workflow }}" >> deployment-summary.md
          echo "- **Run ID**: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> deployment-summary.md
          echo "- **Branch**: ${{ github.ref_name }}" >> deployment-summary.md
          echo "" >> deployment-summary.md
          echo "---" >> deployment-summary.md
          echo "_Deployed with ‚ù§Ô∏è by Mitra AI Team_" >> deployment-summary.md
          cat deployment-summary.md >> $GITHUB_STEP_SUMMARY

      - name: üì¢ Send notifications
        run: |
          echo "::group::üì¢ Notifications"
          STATUS="${{ needs.deploy.result }}"
          ENV="${{ needs.validate.outputs.environment }}"
          URL="${{ needs.deploy.outputs.app_url }}"
          if [ -n "${{ secrets.TEAMS_WEBHOOK_URL }}" ]; then
            if [ "$STATUS" == "success" ]; then
              COLOR="00FF00"
              MESSAGE="‚úÖ Mitra AI deployed successfully to $ENV"
            else
              COLOR="FF0000"
              MESSAGE="‚ùå Mitra AI deployment failed to $ENV"
            fi
            curl -X POST "${{ secrets.TEAMS_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"@type\": \"MessageCard\",
                \"themeColor\": \"$COLOR\",
                \"summary\": \"Mitra AI Deployment\",
                \"sections\": [{
                  \"activityTitle\": \"Mitra AI Deployment\",
                  \"activitySubtitle\": \"Environment: $ENV\",
                  \"activityImage\": \"https://github.com/DenxVil.png\",
                  \"facts\": [
                    {\"name\": \"Status\", \"value\": \"$STATUS\"},
                    {\"name\": \"URL\", \"value\": \"$URL\"},
                    {\"name\": \"Commit\", \"value\": \"${{ github.sha }}\"},
                    {\"name\": \"Triggered by\", \"value\": \"${{ github.actor }}\"}
                  ],
                  \"markdown\": true
                }]"
          fi
          echo "::endgroup::"
